# Spec 10: Organization Inventory Schema Enhancements

**Status:** Draft
**Created:** 2026-02-11
**Complexity:** Medium
**Estimated Implementation:** 2-3 hours

---

## Overview

This specification defines schema enhancements to the organization inventory to support distinguishing between observed data (extracted from documents) and assumed data (generated by assumption engine). The enhancements include new fields for data source tracking, confidence scores, and assumption rationale, while maintaining backward compatibility with existing inventory items.

**Why this exists:** Users must be able to distinguish real organizational data from generated assumptions. Without clear labeling, assumed data could be mistaken for verified information, leading to incorrect M&A decisions. Schema changes ensure transparency and traceability.

**Key principle:** Additive changes only. Existing inventory items continue to work unchanged; new fields are optional with sensible defaults.

---

## Architecture

### Component Positioning

```
Discovery/Assumption Generation
    ↓
FactStore (facts with data_source metadata)
    ↓
Bridge Service (creates inventory items)
    ↓
[THIS COMPONENT] → Enhanced Inventory Schema
    ↓
InventoryStore (persisted with new fields)
    ↓
UI (renders badges/indicators for assumed data)
```

### Dependencies

**Input:**
- Facts from FactStore (may have data_source="assumed")
- Assumption metadata from spec 09 (assumption_basis, confidence)

**Output:**
- Enhanced inventory items with data provenance
- Used by: UI rendering (badges), cost engine (confidence weighting), VDR gap generation

**External Dependencies:**
- `stores.inventory_schemas.INVENTORY_SCHEMAS`
- `stores.inventory_store.InventoryStore`
- Database schema (SQLAlchemy models)

---

## Specification

### 1. Schema Changes

**File:** `stores/inventory_schemas.py`

**Current Organization Schema:**

```python
"organization": {
    "required": ["role"],
    "optional": [
        "name",
        "team",
        "department",
        "headcount",
        "fte",
        "location",
        "reports_to",
        "responsibilities",
        "notes",
    ],
    "id_fields": ["role", "team"],
}
```

**Enhanced Organization Schema:**

```python
"organization": {
    "required": ["role"],
    "optional": [
        "name",
        "team",
        "department",
        "headcount",
        "fte",
        "location",
        "reports_to",
        "responsibilities",
        "notes",

        # NEW FIELDS (spec 10)
        "data_source",           # "observed" | "assumed" | "hybrid"
        "confidence_score",      # 0.0-1.0 (from facts)
        "assumption_basis",      # Free text: e.g., "industry_benchmark:tech"
        "observed_fields",       # List of field names with observed data (for hybrid)
        "assumed_fields",        # List of field names with assumed data (for hybrid)
    ],
    "id_fields": ["role", "team", "entity", "data_source"],  # UPDATED fingerprint
}
```

**Key Changes:**

1. **Added optional fields:** `data_source`, `confidence_score`, `assumption_basis`, `observed_fields`, `assumed_fields`
2. **Updated id_fields:** Now includes `entity` (per CLAUDE.md requirement) and `data_source` to prevent collisions between observed and assumed versions of same role

### 2. Data Source Enum

**File:** `models/organization_models.py` (or new `models/inventory_enums.py`)

```python
from enum import Enum

class InventoryDataSource(Enum):
    """Provenance of inventory item data.

    OBSERVED: Extracted directly from source documents
    ASSUMED: Generated by assumption engine (no document evidence)
    HYBRID: Mix of observed and assumed data (e.g., role observed, reports_to assumed)
    """
    OBSERVED = "observed"
    ASSUMED = "assumed"
    HYBRID = "hybrid"

    @classmethod
    def from_fact(cls, fact: 'Fact') -> 'InventoryDataSource':
        """Determine data source from fact metadata."""
        details = fact.details or {}
        data_source = details.get('data_source', 'observed')

        if data_source == 'assumed':
            return cls.ASSUMED
        elif data_source == 'hybrid':
            return cls.HYBRID
        else:
            return cls.OBSERVED

    @property
    def display_label(self) -> str:
        """Human-readable label for UI."""
        return {
            'observed': 'Documented',
            'assumed': 'Assumed',
            'hybrid': 'Partial',
        }[self.value]

    @property
    def badge_color(self) -> str:
        """CSS class for UI badge."""
        return {
            'observed': 'badge-success',   # Green
            'assumed': 'badge-warning',    # Yellow/Orange
            'hybrid': 'badge-info',        # Blue
        }[self.value]
```

### 3. Confidence Score Guidelines

**Confidence Ranges by Data Source:**

```python
# Confidence score ranges for different data sources
CONFIDENCE_RANGES = {
    'observed': (0.8, 1.0),    # High confidence: directly from documents
    'hybrid': (0.7, 0.9),      # Medium-high: some observed, some assumed
    'assumed': (0.6, 0.8),     # Medium: generated by heuristics
}

def validate_confidence(data_source: str, confidence: float) -> bool:
    """Validate confidence score matches data source expectations."""
    if data_source not in CONFIDENCE_RANGES:
        return False

    min_conf, max_conf = CONFIDENCE_RANGES[data_source]
    return min_conf <= confidence <= max_conf
```

**Confidence Score Sources:**

| Data Source | Confidence Calculation | Example |
|-------------|------------------------|---------|
| **Observed** | From fact extraction confidence (LLM-provided or 1.0 for deterministic parsing) | 0.95 (high confidence extraction) |
| **Assumed** | From assumption engine rules (spec 09) | 0.7 (industry benchmark), 0.6 (inferred) |
| **Hybrid** | Weighted average of observed and assumed fields | (0.9 * 2 + 0.7 * 1) / 3 = 0.83 |

### 4. Fingerprint Calculation Changes

**Current Fingerprint Logic:**

```python
# From stores/inventory_store.py
def _generate_fingerprint(self, inv_type: str, data: Dict[str, Any]) -> str:
    """Generate content-based fingerprint for deduplication."""
    schema = INVENTORY_SCHEMAS[inv_type]
    id_fields = schema["id_fields"]

    # Extract values for ID fields
    id_values = []
    for field in id_fields:
        value = data.get(field, "")
        if value:
            id_values.append(str(value).lower().strip())

    # Hash the concatenated values
    fingerprint_string = "|".join(id_values)
    hash_obj = hashlib.sha256(fingerprint_string.encode())
    hash_hex = hash_obj.hexdigest()[:8]

    prefix = INVENTORY_PREFIXES[inv_type]
    return f"I-{prefix}-{hash_hex}"
```

**Enhanced Fingerprint Logic:**

```python
def _generate_fingerprint(self, inv_type: str, data: Dict[str, Any]) -> str:
    """Generate content-based fingerprint for deduplication.

    Updated for spec 10: Include entity and data_source in fingerprint
    to prevent collisions between:
        - Target vs Buyer org items
        - Observed vs Assumed versions of same role
    """
    schema = INVENTORY_SCHEMAS[inv_type]
    id_fields = schema["id_fields"]

    # Extract values for ID fields
    id_values = []
    for field in id_fields:
        value = data.get(field, "")
        if value:
            id_values.append(str(value).lower().strip())
        elif field == "entity":
            # Entity is REQUIRED per CLAUDE.md, but default to target if missing
            id_values.append("target")
        elif field == "data_source":
            # Default to observed if not specified
            id_values.append("observed")

    # Hash the concatenated values
    fingerprint_string = "|".join(id_values)
    hash_obj = hashlib.sha256(fingerprint_string.encode())
    hash_hex = hash_obj.hexdigest()[:8]

    prefix = INVENTORY_PREFIXES[inv_type]
    return f"I-{prefix}-{hash_hex}"
```

**Impact:** Same role (e.g., "VP of Infrastructure") can have TWO inventory items:
- `I-ORG-abc123` (data_source="observed", from document)
- `I-ORG-def456` (data_source="assumed", from assumption engine)

This is INTENTIONAL — allows displaying both observed and assumed data side-by-side.

### 5. Inventory Item Creation (Bridge Service)

**Location:** `services/organization_bridge.py`

**Updated Helper Function:**

```python
def _create_staff_from_fact(fact: Fact, deal_id: str = "") -> StaffMember:
    """
    Create StaffMember from fact, preserving data source metadata.

    Updated for spec 10: Extract data_source, confidence, assumption_basis
    from fact.details and include in StaffMember.
    """
    details = fact.details or {}

    # Extract data source metadata (NEW)
    data_source = details.get('data_source', 'observed')
    confidence = fact.confidence if hasattr(fact, 'confidence') else 1.0
    assumption_basis = details.get('assumption_basis', '')

    # Determine which fields are observed vs assumed (for hybrid)
    observed_fields = []
    assumed_fields = []
    if data_source == 'hybrid':
        # Check each field's provenance (stored in fact.details metadata)
        field_provenance = details.get('field_provenance', {})
        for field_name, provenance in field_provenance.items():
            if provenance == 'observed':
                observed_fields.append(field_name)
            elif provenance == 'assumed':
                assumed_fields.append(field_name)

    # Create StaffMember with enhanced fields
    return StaffMember(
        staff_id=gen_id("staff"),
        name=details.get('name', ''),
        role=fact.item,
        team=details.get('team', ''),
        department=details.get('department', ''),
        reports_to=details.get('reports_to', ''),
        role_category=_determine_category_from_name(fact.item),
        employment_type=EmploymentType.FTE,  # Default
        annual_cost=details.get('annual_cost', 0),
        tenure_years=0,
        headcount=details.get('count', 1),
        deal_id=deal_id,

        # NEW FIELDS (spec 10)
        data_source=data_source,
        confidence_score=confidence,
        assumption_basis=assumption_basis if data_source == 'assumed' else None,
        observed_fields=observed_fields if data_source == 'hybrid' else None,
        assumed_fields=assumed_fields if data_source == 'hybrid' else None,
    )
```

### 6. Migration Strategy for Existing Inventory

**CRITICAL (P0 FIX):** Changing id_fields will orphan existing inventory items. Migration required.

**Problem:**
- Existing items: `id_fields = ["role", "team"]` → ID like `I-ORG-abc123`
- New items: `id_fields = ["role", "team", "entity", "data_source"]` → ID like `I-ORG-def456`
- Same role gets TWO different IDs → duplication, broken queries

**Solution: Two-Phase Migration**

**Phase 1: Pre-Deployment - Backfill Existing Data**

```python
# Migration script: migrations/backfill_org_inventory_data_source.py

def backfill_existing_org_inventory():
    """
    Backfill data_source field for existing organization inventory items.

    Run BEFORE deploying code with new fingerprinting.
    """
    from stores.inventory_store import InventoryStore
    from stores.inventory_schemas import INVENTORY_SCHEMAS

    # For each deal
    for deal in get_all_deals():
        store = InventoryStore(deal_id=deal.deal_id)

        # Get all organization items
        org_items = [
            item for item in store._items.values()
            if item.inventory_type == "organization"
        ]

        # Backfill data_source field
        for item in org_items:
            if 'data_source' not in item.data:
                # Existing items are all observed (came from documents)
                item.data['data_source'] = 'observed'
                item.data['confidence_score'] = 1.0  # Observed data is high confidence
                item.data.setdefault('entity', 'target')  # Default to target if missing

                logger.info(f"Backfilled data_source for item {item.item_id}")

        # Save updated store
        store.save()

    logger.info("Backfill complete")
```

**Phase 2: Post-Deployment - Regenerate IDs (Optional)**

If you want to regenerate IDs with new fingerprinting (BREAKING CHANGE):

```python
# Migration script: migrations/regenerate_org_inventory_ids.py

def regenerate_org_inventory_ids():
    """
    Regenerate organization inventory IDs with new fingerprinting.

    WARNING: This is a BREAKING CHANGE. Any foreign key references
    to old IDs will break. Update UI, reports, cost engine first.
    """
    from stores.inventory_store import InventoryStore
    from stores.id_generator import generate_inventory_id

    # For each deal
    for deal in get_all_deals():
        store = InventoryStore(deal_id=deal.deal_id)

        # Track old_id -> new_id mapping
        id_mapping = {}

        # Get all organization items
        org_items = [
            item for item in store._items.values()
            if item.inventory_type == "organization"
        ]

        # Regenerate IDs
        new_items = {}
        for item in org_items:
            old_id = item.item_id

            # Generate new ID with updated fingerprinting
            new_id = generate_inventory_id(
                inventory_type="organization",
                data=item.data,
                entity=item.entity,
                deal_id=deal.deal_id
            )

            # Update item
            item.item_id = new_id
            new_items[new_id] = item
            id_mapping[old_id] = new_id

            logger.info(f"Regenerated ID: {old_id} -> {new_id}")

        # Replace store items
        store._items = new_items

        # Update foreign key references (TODO: implement based on your schema)
        # update_cost_engine_references(id_mapping)
        # update_report_references(id_mapping)
        # update_ui_bookmarks(id_mapping)

        # Save updated store
        store.save()

    logger.info("ID regeneration complete")
```

**Recommended Approach: Phase 1 Only**

DO NOT run Phase 2 (ID regeneration) unless absolutely necessary. Instead:
1. Backfill `data_source='observed'` for existing items (Phase 1)
2. Deploy new code with updated fingerprinting
3. New items get new IDs (with data_source in fingerprint)
4. Existing items keep old IDs (backward compatible)
5. Both coexist peacefully

**Trade-off:** Inconsistent fingerprinting (old items don't include data_source, new items do), but avoids breaking changes.

**Migration Checklist:**
- [ ] Run Phase 1 backfill script on staging
- [ ] Verify all org items have `data_source`, `entity` fields
- [ ] Deploy new code
- [ ] Monitor for ID collisions (should be none if backfill succeeded)
- [ ] Optional: Run Phase 2 regeneration (only if you need consistent fingerprinting)

### 7. Database Schema Changes

**File:** `web/database.py` (SQLAlchemy models)

**Current Fact Model:**

```python
class Fact(Base):
    __tablename__ = 'facts'

    id = Column(Integer, primary_key=True)
    fact_id = Column(String(50), unique=True, nullable=False, index=True)
    deal_id = Column(String(50), ForeignKey('deals.deal_id'), nullable=False, index=True)
    domain = Column(String(50), nullable=False)
    category = Column(String(50), nullable=False)
    item = Column(Text, nullable=False)
    entity = Column(String(20), nullable=False)  # "target" | "buyer"
    details = Column(JSON)
    evidence = Column(JSON)
    confidence = Column(Float, default=1.0)
    created_at = Column(DateTime, default=datetime.utcnow)
    # ... other fields
```

**Enhanced Fact Model (no changes needed):**

Facts already have `details` (JSON) and `confidence` (Float), which is sufficient to store data_source and assumption_basis in `details`. No database migration required.

**InventoryItem Model (if persisted separately):**

If inventory items are stored in a separate table (not just generated on-the-fly), add optional columns:

```python
class InventoryItem(Base):
    __tablename__ = 'inventory_items'

    id = Column(Integer, primary_key=True)
    inventory_id = Column(String(50), unique=True, nullable=False, index=True)
    deal_id = Column(String(50), ForeignKey('deals.deal_id'), nullable=False, index=True)
    inventory_type = Column(String(50), nullable=False)  # "application", "organization", etc.
    entity = Column(String(20), nullable=False)
    data = Column(JSON)  # Contains all inventory fields

    # NEW COLUMNS (spec 10) - optional, can also live in data JSON
    data_source = Column(String(20), default='observed')  # "observed" | "assumed" | "hybrid"
    confidence_score = Column(Float, default=1.0)
    assumption_basis = Column(Text, nullable=True)

    created_at = Column(DateTime, default=datetime.utcnow)
```

**Migration Strategy:**

If using Alembic migrations:

```python
# Migration file: versions/XXX_add_inventory_data_source.py

def upgrade():
    # Add new columns with defaults (backward compatible)
    op.add_column('inventory_items',
                  sa.Column('data_source', sa.String(20), server_default='observed'))
    op.add_column('inventory_items',
                  sa.Column('confidence_score', sa.Float(), server_default='1.0'))
    op.add_column('inventory_items',
                  sa.Column('assumption_basis', sa.Text(), nullable=True))

def downgrade():
    op.drop_column('inventory_items', 'assumption_basis')
    op.drop_column('inventory_items', 'confidence_score')
    op.drop_column('inventory_items', 'data_source')
```

### 7. UI Rendering Changes

**File:** `web/templates/organization/staffing_tree.html` (example)

**Display Badge for Data Source:**

```html
<!-- Existing role display -->
<div class="staff-member">
    <strong>{{ staff.role }}</strong>

    <!-- NEW: Data source badge (spec 10) -->
    {% if staff.data_source %}
        <span class="badge {{ staff.data_source_badge_class }}">
            {{ staff.data_source_display }}
        </span>
    {% endif %}

    <!-- Existing fields -->
    <div class="staff-details">
        Team: {{ staff.team }}<br>
        Reports to: {{ staff.reports_to }}

        <!-- NEW: Show confidence and basis for assumed data -->
        {% if staff.data_source == 'assumed' %}
            <div class="assumption-info text-muted">
                <small>
                    Confidence: {{ (staff.confidence_score * 100)|int }}%
                    {% if staff.assumption_basis %}
                        | Basis: {{ staff.assumption_basis }}
                    {% endif %}
                </small>
            </div>
        {% endif %}
    </div>
</div>
```

**CSS for Badges:**

```css
/* web/static/css/inventory.css */

.badge-success {
    background-color: #28a745;  /* Green for observed */
    color: white;
}

.badge-warning {
    background-color: #ffc107;  /* Yellow for assumed */
    color: black;
}

.badge-info {
    background-color: #17a2b8;  /* Blue for hybrid */
    color: white;
}

.assumption-info {
    font-size: 0.85em;
    margin-top: 5px;
    padding: 5px;
    background-color: #fff3cd;  /* Light yellow background */
    border-left: 3px solid #ffc107;
}
```

**Tooltip for Assumptions:**

```html
<!-- Add tooltip to explain assumption basis -->
<span class="badge badge-warning"
      data-toggle="tooltip"
      data-placement="top"
      title="This data was generated by assumption engine based on {{ staff.assumption_basis }}">
    Assumed
</span>
```

---

## Verification Strategy

### Unit Tests

**File:** `tests/test_inventory_schema_enhancements.py`

**Test Cases:**

1. **test_schema_has_new_fields**
   - Verify INVENTORY_SCHEMAS["organization"] includes data_source, confidence_score, etc.

2. **test_fingerprint_includes_data_source**
   - Create two items with same role/team but different data_source
   - Verify fingerprints are different

3. **test_fingerprint_includes_entity**
   - Create two items with same role but different entity
   - Verify fingerprints are different

4. **test_data_source_enum_display**
   - Verify InventoryDataSource.OBSERVED.display_label == "Documented"
   - Verify badge_color property returns correct CSS class

5. **test_confidence_validation**
   - Verify observed data with 0.95 confidence passes validation
   - Verify assumed data with 0.5 confidence fails validation (too low)

6. **test_backward_compatibility**
   - Create inventory item without new fields
   - Verify defaults applied (data_source="observed", confidence=1.0)

### Integration Tests

**File:** `tests/integration/test_inventory_with_assumptions.py`

**Test Cases:**

1. **test_observed_and_assumed_coexist**
   - Create fact with data_source="observed"
   - Create assumption with same role, data_source="assumed"
   - Verify inventory has TWO items with different IDs

2. **test_ui_renders_badges**
   - Generate HTML for staffing tree with mixed data sources
   - Verify badges present in HTML output

3. **test_entity_propagation_with_assumptions**
   - Generate assumptions for target entity
   - Verify all inventory items have entity="target"

### Manual Verification

**Steps:**

1. Run full pipeline on doc with partial org data
2. Verify UI shows badges for assumed data
3. Check inventory counts (should have both observed + assumed)
4. Hover tooltips to see assumption basis

**Success Criteria:**
- Badges clearly distinguish observed vs assumed
- Confidence scores displayed for assumed data
- No confusion between data sources

---

## Benefits

### Why This Approach

**Additive schema changes** provide:
- Backward compatibility (existing data works unchanged)
- No breaking changes to API/UI
- Easy rollback (ignore new fields)

**Explicit data_source in fingerprint** prevents:
- Cross-entity merging (target/buyer collision)
- Observed/assumed collision (can have both)
- Silent data overwrites

**UI transparency** (badges, confidence, basis) provides:
- Clear distinction between real and assumed data
- Traceability (users can see assumption logic)
- Trust (users know what's verified vs inferred)

---

## Expectations

### Success Metrics

**Schema Integrity:**
- All new fields optional (backward compatible)
- Fingerprints never collide across entity or data_source
- Confidence scores within expected ranges

**UI Clarity:**
- 100% of assumed items show badge in UI
- Tooltip explains assumption basis
- No user confusion in testing

---

## Risks & Mitigations

| Risk | Mitigation |
|------|------------|
| **Fingerprint collisions increase storage** | Acceptable trade-off for data clarity |
| **UI cluttered with badges** | Use subtle styling, show on hover if too busy |
| **Database migration fails** | Test on staging, use nullable columns with defaults |

---

## Results Criteria

### Acceptance Criteria

- [ ] INVENTORY_SCHEMAS["organization"] includes 5 new optional fields
- [ ] id_fields includes entity and data_source
- [ ] InventoryDataSource enum with display_label and badge_color
- [ ] Fingerprint calculation includes entity and data_source
- [ ] UI templates render badges for data_source
- [ ] CSS classes for badges defined
- [ ] Backward compatibility: old items get defaults
- [ ] All unit tests pass (6+ tests)
- [ ] Integration tests pass

---

**Estimated Implementation Time:** 2-3 hours
**Confidence:** High (straightforward schema changes)
