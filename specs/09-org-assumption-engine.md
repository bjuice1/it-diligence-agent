# Spec 09: Organization Assumption Engine

**Status:** Draft
**Created:** 2026-02-11
**Complexity:** High
**Estimated Implementation:** 6-8 hours

---

## Overview

This specification defines the assumption generation engine that creates synthetic organizational structure data when source documents lack complete hierarchy information. The engine uses industry benchmarks, company size heuristics, and role title inference to build reasonable organizational assumptions that populate the inventory alongside observed data.

**Why this exists:** M&A VDR packages frequently omit org charts, reporting lines, and management layers. Rather than presenting empty organization analysis, the system generates reasonable assumptions based on industry norms, allowing analysts to proceed with risk assessment and cost estimation while flagging assumptions for later validation.

**Key principle:** Assumptions are transparent (labeled as such), conservative (avoid over-optimistic structures), and evidence-based (cite industry benchmarks or inference rules).

---

## Architecture

### Component Positioning

```
HierarchyDetector (spec 08)
    ↓
HierarchyPresence (status=PARTIAL or MISSING)
    ↓
[THIS COMPONENT] → AssumptionEngine
    ↓
OrganizationAssumption[] (synthetic facts)
    ↓
FactStore (merged with observed facts)
    ↓
Bridge Service → Inventory (spec 11)
```

### Dependencies

**Input:**
- `HierarchyPresence` from spec 08 (knows what's missing)
- Observed org facts from FactStore (provides context: headcount, team names, known leadership)
- Company profile data (industry, size, geography) from business context

**Output:**
- List of `OrganizationAssumption` objects (synthetic facts)
- Used by: Bridge service (spec 11) to populate inventory

**External Dependencies:**
- `services.org_hierarchy_detector.HierarchyPresence`
- `stores.fact_store.FactStore, Fact`
- `models.organization_models` (for role categories)

---

## Specification

### 1. Data Contract: OrganizationAssumption

```python
from dataclasses import dataclass, field
from typing import Dict, Any, List
from datetime import datetime

@dataclass
class OrganizationAssumption:
    """A synthetic organizational fact generated by assumption logic.

    Assumptions are created when source documents lack hierarchy data.
    They populate inventory alongside observed facts but are labeled
    to distinguish from real data.
    """
    # Core fact fields (match Fact schema)
    item: str                       # e.g., "VP of Infrastructure"
    category: str                   # "leadership", "roles", etc.
    domain: str = "organization"
    entity: str = "target"          # "target" or "buyer"

    # Assumption metadata
    data_source: str = "assumed"    # Always "assumed"
    confidence: float = 0.7         # 0.6-0.8 for assumptions
    assumption_basis: str = ""      # e.g., "industry_benchmark:tech"

    # Structured data (matches fact.details)
    details: Dict[str, Any] = field(default_factory=dict)

    # Synthetic evidence (for consistency with fact schema)
    evidence: Dict[str, str] = field(default_factory=dict)

    # Metadata
    created_at: str = field(default_factory=lambda: datetime.utcnow().isoformat())

    def to_fact(self) -> Dict[str, Any]:
        """Convert to Fact-compatible dict for FactStore insertion."""
        return {
            'item': self.item,
            'category': self.category,
            'domain': self.domain,
            'entity': self.entity,
            'confidence': self.confidence,
            'details': {
                **self.details,
                'data_source': self.data_source,
                'assumption_basis': self.assumption_basis,
            },
            'evidence': self.evidence,
        }
```

### 2. Assumption Generation Strategy

**Location:** `services/org_assumption_engine.py` (new file)

**Main Function:**

```python
def generate_org_assumptions(
    fact_store: FactStore,
    hierarchy_presence: HierarchyPresence,
    entity: str = "target",
    company_profile: Optional[Dict[str, Any]] = None
) -> List[OrganizationAssumption]:
    """
    Generate organizational assumptions based on missing data.

    Args:
        fact_store: FactStore with observed org facts
        hierarchy_presence: Detection results from spec 08
        entity: "target" or "buyer"
        company_profile: Optional company context (industry, size, geography)

    Returns:
        List of OrganizationAssumption objects to merge into FactStore

    Strategy:
        1. Extract context from observed facts (known headcount, teams, leadership)
        2. Determine company characteristics (size, industry)
        3. Apply assumption heuristics based on what's missing:
            - MISSING: Generate full structure (layers, span, reporting lines)
            - PARTIAL: Supplement existing data (fill gaps only)
        4. Return synthetic facts with confidence scores
    """
    pass  # Implementation below
```

### 3. Industry Benchmarks

**Source Data (Embedded Constants):**

```python
# Industry benchmarks for organizational depth
# Sources: Gartner IT Staffing Reports 2024, McKinsey Org Design Studies
INDUSTRY_ORG_DEPTH = {
    'technology': {
        'typical_layers': 3,      # CIO → Director → Manager → IC
        'span_leadership': 8,     # VPs/Directors manage 6-10 (avg 8)
        'span_middle': 6,         # Managers manage 5-7 (avg 6)
        'rationale': 'Tech orgs favor flat structures, empowered teams'
    },
    'financial_services': {
        'typical_layers': 4,      # CIO → VP → Director → Manager → IC
        'span_leadership': 6,
        'span_middle': 5,
        'rationale': 'Financial services balance control with efficiency'
    },
    'manufacturing': {
        'typical_layers': 5,      # CIO → VP → Director → Manager → Lead → IC
        'span_leadership': 5,
        'span_middle': 7,
        'rationale': 'Manufacturing has deeper hierarchies, operational focus'
    },
    'retail': {
        'typical_layers': 4,
        'span_leadership': 7,
        'span_middle': 8,
        'rationale': 'Retail IT supports distributed operations, moderate depth'
    },
    'healthcare': {
        'typical_layers': 4,
        'span_leadership': 6,
        'span_middle': 6,
        'rationale': 'Healthcare IT complex, regulatory, moderate hierarchy'
    },
    'default': {
        'typical_layers': 4,      # Conservative default
        'span_leadership': 6,
        'span_middle': 6,
        'rationale': 'Default assumption for unknown industries'
    }
}

# Map company profile industries to benchmark keys
INDUSTRY_MAPPING = {
    'technology': 'technology',
    'software': 'technology',
    'saas': 'technology',
    'fintech': 'financial_services',
    'financial services': 'financial_services',
    'banking': 'financial_services',
    'insurance': 'financial_services',
    'manufacturing': 'manufacturing',
    'industrial': 'manufacturing',
    'retail': 'retail',
    'e-commerce': 'retail',
    'healthcare': 'healthcare',
    'life sciences': 'healthcare',
    'pharma': 'healthcare',
}
```

### 4. Company Size Heuristics

**Headcount-Based Adjustments:**

```python
def _adjust_for_company_size(
    base_layers: int,
    base_span_leadership: int,
    base_span_middle: int,
    total_it_headcount: int
) -> Dict[str, int]:
    """
    Adjust org structure assumptions based on IT headcount.

    Smaller orgs → flatter (fewer layers, wider span)
    Larger orgs → deeper (more layers, narrower span for control)

    Args:
        base_layers: Industry-based layer count
        base_span_leadership: Industry-based leadership span
        base_span_middle: Industry-based middle management span
        total_it_headcount: Total IT staff count

    Returns:
        Adjusted structure parameters
    """
    if total_it_headcount < 20:
        # Very small IT (<20): Extremely flat
        return {
            'layers': max(2, base_layers - 2),  # CIO → IC (maybe one layer)
            'span_leadership': min(15, base_span_leadership + 4),
            'span_middle': min(12, base_span_middle + 3),
            'size_category': 'very_small'
        }
    elif total_it_headcount < 50:
        # Small IT (20-50): Flat
        return {
            'layers': max(2, base_layers - 1),
            'span_leadership': base_span_leadership + 2,
            'span_middle': base_span_middle + 1,
            'size_category': 'small'
        }
    elif total_it_headcount < 150:
        # Medium IT (50-150): Standard
        return {
            'layers': base_layers,
            'span_leadership': base_span_leadership,
            'span_middle': base_span_middle,
            'size_category': 'medium'
        }
    elif total_it_headcount < 500:
        # Large IT (150-500): Slightly deeper
        return {
            'layers': base_layers + 1,
            'span_leadership': max(4, base_span_leadership - 1),
            'span_middle': max(4, base_span_middle - 1),
            'size_category': 'large'
        }
    else:
        # Very large IT (500+): Deep hierarchy
        return {
            'layers': base_layers + 2,
            'span_leadership': max(4, base_span_leadership - 2),
            'span_middle': max(4, base_span_middle - 1),
            'size_category': 'very_large'
        }
```

### 5. Role Title Inference

**Hierarchy Levels from Role Titles:**

```python
ROLE_HIERARCHY_LEVELS = {
    # Executive level (layer 1)
    'cio': 1,
    'chief information officer': 1,
    'cto': 1,
    'chief technology officer': 1,
    'vp': 2,
    'vice president': 2,
    'svp': 2,
    'senior vice president': 2,
    'evp': 2,
    'executive vice president': 2,

    # Director level (layer 3)
    'director': 3,
    'senior director': 3,

    # Manager level (layer 4)
    'manager': 4,
    'senior manager': 4,
    'team lead': 4,
    'lead': 4,

    # Individual contributor (layer 5)
    'engineer': 5,
    'analyst': 5,
    'specialist': 5,
    'administrator': 5,
    'coordinator': 5,
    'senior engineer': 5,
    'principal engineer': 4,  # Principal ICs often equivalent to managers
    'staff engineer': 4,
    'architect': 4,
}

def _infer_layer_from_title(role_title: str) -> Optional[int]:
    """
    Infer organizational layer from role title.

    Returns layer number (1=top, higher=lower) or None if ambiguous.
    """
    title_lower = role_title.lower().strip()

    # Exact match
    if title_lower in ROLE_HIERARCHY_LEVELS:
        return ROLE_HIERARCHY_LEVELS[title_lower]

    # Partial match (contains keyword)
    for keyword, layer in ROLE_HIERARCHY_LEVELS.items():
        if keyword in title_lower:
            return layer

    return None  # Can't infer
```

### 6. Assumption Generation Logic

**For MISSING Hierarchy (Complete Generation):**

```python
def _generate_full_structure_assumptions(
    observed_facts: List[Fact],
    industry_params: Dict[str, Any],
    total_it_headcount: int,
    entity: str
) -> List[OrganizationAssumption]:
    """
    Generate complete organizational structure when none exists.

    Steps:
        1. Determine target layer count and span from industry + size
        2. Allocate headcount across layers using span ratios
        3. Generate leadership roles (CIO, VPs, Directors)
        4. Generate manager roles for each team
        5. Generate reporting lines (each role reports to layer above)
        6. Generate span of control metadata

    Returns list of assumptions covering:
        - Leadership structure (CIO → VPs → Directors)
        - Management layers (Managers for each team)
        - Reporting lines (reports_to fields)
        - Span of control notes
    """
    assumptions = []

    # Extract known teams from observed facts
    team_facts = [f for f in observed_facts if f.category == "central_it"]
    known_teams = [f.item for f in team_facts]

    if not known_teams:
        # No team data either, create default teams
        known_teams = ["Infrastructure", "Applications", "Security", "Service Desk"]

    # Get structure parameters
    layers = industry_params['layers']
    span_leadership = industry_params['span_leadership']
    span_middle = industry_params['span_middle']

    # Generate CIO
    assumptions.append(OrganizationAssumption(
        item="Chief Information Officer",
        category="leadership",
        entity=entity,
        confidence=0.8,
        assumption_basis=f"standard_leadership_structure",
        details={
            'role': 'CIO',
            'layer': 1,
            'reports_to': 'CEO',
            'span_of_control': len(known_teams) if len(known_teams) <= span_leadership else span_leadership,
        },
        evidence={
            'exact_quote': 'Assumed: Standard IT leadership structure with CIO role',
            'source_section': 'Assumption Engine',
        }
    ))

    # Generate VPs/Directors for each major team
    if layers >= 3:
        for team in known_teams[:span_leadership]:  # Cap at span limit
            # VP level
            assumptions.append(OrganizationAssumption(
                item=f"VP of {team}",
                category="leadership",
                entity=entity,
                confidence=0.7,
                assumption_basis=f"industry_benchmark:{industry_params.get('industry', 'default')}",
                details={
                    'role': f'VP of {team}',
                    'layer': 2,
                    'team': team,
                    'reports_to': 'Chief Information Officer',
                    'span_of_control': span_middle,
                },
                evidence={
                    'exact_quote': f'Assumed: VP-level leadership for {team} team',
                    'source_section': 'Assumption Engine',
                }
            ))

            # Manager level (if layers >= 4)
            if layers >= 4:
                assumptions.append(OrganizationAssumption(
                    item=f"{team} Manager",
                    category="roles",
                    entity=entity,
                    confidence=0.65,
                    assumption_basis=f"team_structure_inference",
                    details={
                        'role': f'{team} Manager',
                        'layer': 3,
                        'team': team,
                        'reports_to': f'VP of {team}',
                        'span_of_control': span_middle,
                        'count': 1,  # Placeholder count
                    },
                    evidence={
                        'exact_quote': f'Assumed: Manager role for {team} team',
                        'source_section': 'Assumption Engine',
                    }
                ))

    # Generate org depth note
    assumptions.append(OrganizationAssumption(
        item="Organizational Depth",
        category="skills",
        entity=entity,
        confidence=0.7,
        assumption_basis=f"industry_benchmark:{industry_params.get('industry', 'default')}",
        details={
            'expected_layers': layers,
            'rationale': industry_params.get('rationale', 'Industry standard'),
        },
        evidence={
            'exact_quote': f'Assumed: {layers}-layer organization structure based on industry norms',
            'source_section': 'Assumption Engine',
        }
    ))

    return assumptions
```

**For PARTIAL Hierarchy (Gap Filling):**

```python
def _generate_gap_filling_assumptions(
    observed_facts: List[Fact],
    hierarchy_presence: HierarchyPresence,
    industry_params: Dict[str, Any],
    entity: str
) -> List[OrganizationAssumption]:
    """
    Generate assumptions to fill gaps in partial hierarchy data.

    Strategy:
        - If leadership exists but no reports_to: Infer reporting lines from titles
        - If teams exist but no managers: Generate manager roles
        - If managers exist but no span: Assign default span values
    """
    assumptions = []

    # Get observed leadership and roles
    leadership_facts = [f for f in observed_facts if f.category == "leadership"]
    role_facts = [f for f in observed_facts if f.category == "roles"]

    # Gap 1: Missing reports_to for known roles
    if not hierarchy_presence.has_reports_to:
        # Infer reporting lines from role titles
        roles_by_layer = {}
        for fact in leadership_facts + role_facts:
            layer = _infer_layer_from_title(fact.item)
            if layer:
                if layer not in roles_by_layer:
                    roles_by_layer[layer] = []
                roles_by_layer[layer].append(fact.item)

        # Create reports_to assumptions (layer N reports to layer N-1)
        for layer in sorted(roles_by_layer.keys()):
            if layer > 1:  # Not top level
                parent_layer = layer - 1
                if parent_layer in roles_by_layer:
                    parent_role = roles_by_layer[parent_layer][0]  # Assume reports to first in parent layer
                    for role in roles_by_layer[layer]:
                        assumptions.append(OrganizationAssumption(
                            item=role,
                            category="leadership" if layer <= 3 else "roles",
                            entity=entity,
                            confidence=0.6,
                            assumption_basis="inferred_from_role_title",
                            details={
                                'role': role,
                                'reports_to': parent_role,
                                'inferred': True,
                            },
                            evidence={
                                'exact_quote': f'Assumed: {role} reports to {parent_role} (inferred from titles)',
                                'source_section': 'Assumption Engine',
                            }
                        ))

    # Gap 2: Missing span of control
    if not hierarchy_presence.has_span_data:
        for fact in leadership_facts:
            layer = _infer_layer_from_title(fact.item)
            if layer and layer <= 3:  # Leadership layers
                assumptions.append(OrganizationAssumption(
                    item=fact.item,
                    category="leadership",
                    entity=entity,
                    confidence=0.65,
                    assumption_basis="default_span_of_control",
                    details={
                        'role': fact.item,
                        'span_of_control': industry_params['span_leadership'],
                    },
                    evidence={
                        'exact_quote': f'Assumed: Span of control {industry_params["span_leadership"]} (industry average)',
                        'source_section': 'Assumption Engine',
                    }
                ))

    return assumptions
```

### 7. Complete Implementation

**File:** `services/org_assumption_engine.py`

```python
"""
Organization Assumption Engine

Generates synthetic organizational structure when source docs lack hierarchy.
Part of adaptive organization extraction feature (spec 09).
"""

import logging
from typing import List, Dict, Any, Optional
from dataclasses import dataclass, field
from datetime import datetime

from stores.fact_store import FactStore, Fact
from services.org_hierarchy_detector import HierarchyPresence, HierarchyPresenceStatus

logger = logging.getLogger(__name__)

# (Include all constants from sections 3-5 above)

@dataclass
class OrganizationAssumption:
    """Synthetic organizational fact generated by assumption logic."""
    item: str
    category: str
    domain: str = "organization"
    entity: str = "target"
    data_source: str = "assumed"
    confidence: float = 0.7
    assumption_basis: str = ""
    details: Dict[str, Any] = field(default_factory=dict)
    evidence: Dict[str, str] = field(default_factory=dict)
    created_at: str = field(default_factory=lambda: datetime.utcnow().isoformat())

    def to_fact(self) -> Dict[str, Any]:
        """Convert to Fact-compatible dict."""
        return {
            'item': self.item,
            'category': self.category,
            'domain': self.domain,
            'entity': self.entity,
            'confidence': self.confidence,
            'details': {
                **self.details,
                'data_source': self.data_source,
                'assumption_basis': self.assumption_basis,
            },
            'evidence': self.evidence,
        }


def generate_org_assumptions(
    fact_store: FactStore,
    hierarchy_presence: HierarchyPresence,
    entity: str = "target",
    company_profile: Optional[Dict[str, Any]] = None
) -> List[OrganizationAssumption]:
    """Generate organizational assumptions based on missing data."""

    # Don't generate assumptions if hierarchy is FULL
    if hierarchy_presence.status == HierarchyPresenceStatus.FULL:
        logger.info(f"Hierarchy is FULL for {entity}, skipping assumption generation")
        return []

    # Extract observed facts
    observed_facts = [
        f for f in fact_store.facts
        if f.domain == "organization" and f.entity == entity
    ]

    # Determine industry and size
    industry = _determine_industry(company_profile, observed_facts)
    total_it_headcount = _extract_total_headcount(observed_facts)

    # Get base industry parameters
    industry_key = INDUSTRY_MAPPING.get(industry.lower(), 'default')
    industry_params = INDUSTRY_ORG_DEPTH[industry_key].copy()
    industry_params['industry'] = industry

    # Adjust for company size
    size_adjusted = _adjust_for_company_size(
        base_layers=industry_params['typical_layers'],
        base_span_leadership=industry_params['span_leadership'],
        base_span_middle=industry_params['span_middle'],
        total_it_headcount=total_it_headcount
    )
    industry_params.update(size_adjusted)

    logger.info(f"Generating assumptions for {entity}: industry={industry}, "
                f"headcount={total_it_headcount}, layers={industry_params['layers']}")

    # Generate assumptions based on status
    if hierarchy_presence.status == HierarchyPresenceStatus.MISSING:
        assumptions = _generate_full_structure_assumptions(
            observed_facts=observed_facts,
            industry_params=industry_params,
            total_it_headcount=total_it_headcount,
            entity=entity
        )
    else:  # PARTIAL
        assumptions = _generate_gap_filling_assumptions(
            observed_facts=observed_facts,
            hierarchy_presence=hierarchy_presence,
            industry_params=industry_params,
            entity=entity
        )

    logger.info(f"Generated {len(assumptions)} assumptions for {entity}")

    return assumptions


def _determine_industry(
    company_profile: Optional[Dict[str, Any]],
    observed_facts: List[Fact]
) -> str:
    """Determine company industry from profile or facts."""
    if company_profile and 'industry' in company_profile:
        return company_profile['industry']

    # Fallback: try to infer from facts (look for industry mentions)
    for fact in observed_facts:
        evidence_text = str(fact.evidence).lower() if fact.evidence else ""
        for industry_keyword in INDUSTRY_MAPPING.keys():
            if industry_keyword in evidence_text:
                return industry_keyword

    return 'default'


def _extract_total_headcount(observed_facts: List[Fact]) -> int:
    """Extract total IT headcount from facts."""
    # Check budget facts first (authoritative)
    for fact in observed_facts:
        if fact.category == "budget":
            details = fact.details or {}
            if 'total_it_headcount' in details:
                return int(details['total_it_headcount'])

    # Fallback: sum team headcounts
    total = 0
    for fact in observed_facts:
        if fact.category == "central_it":
            details = fact.details or {}
            if 'headcount' in details:
                try:
                    total += int(details['headcount'])
                except (ValueError, TypeError):
                    pass

    # Default if no headcount found
    return total if total > 0 else 50  # Conservative default


# (Include _adjust_for_company_size, _infer_layer_from_title,
#  _generate_full_structure_assumptions, _generate_gap_filling_assumptions
#  from sections 4-6 above)
```

---

## Verification Strategy

### Unit Tests

**File:** `tests/test_org_assumption_engine.py`

**Test Cases:**

1. **test_generate_assumptions_missing_hierarchy**
   - Input: MISSING status, 50 headcount, tech industry
   - Expected: 5-10 assumptions (CIO, VPs, structure notes), confidence 0.65-0.8

2. **test_generate_assumptions_partial_hierarchy**
   - Input: PARTIAL status, leadership exists but no reports_to
   - Expected: reports_to assumptions only, confidence 0.6-0.7

3. **test_generate_assumptions_full_hierarchy**
   - Input: FULL status
   - Expected: Empty list (no assumptions needed)

4. **test_industry_mapping_tech**
   - Input: tech industry, 100 headcount
   - Expected: 3 layers, flat structure

5. **test_industry_mapping_manufacturing**
   - Input: manufacturing industry, 100 headcount
   - Expected: 5 layers, deeper structure

6. **test_company_size_very_small**
   - Input: 15 headcount
   - Expected: 2 layers, wide span

7. **test_company_size_very_large**
   - Input: 600 headcount
   - Expected: 5-6 layers, narrow span

8. **test_role_title_inference**
   - Input: "VP of Infrastructure"
   - Expected: Layer 2

9. **test_assumption_to_fact_conversion**
   - Input: OrganizationAssumption object
   - Expected: Valid fact dict with data_source="assumed"

### Integration Tests

**File:** `tests/integration/test_assumption_engine_integration.py`

**Test Cases:**

1. **test_assumptions_merge_with_facts**
   - Generate assumptions, merge into FactStore
   - Verify fact_store has both observed + assumed facts

2. **test_assumptions_populate_inventory**
   - Run full pipeline with MISSING hierarchy doc
   - Verify inventory contains assumed roles with data_source labels

3. **test_assumptions_entity_propagation**
   - Generate assumptions for target
   - Verify all assumptions have entity="target"

### Manual Verification

**Steps:**

1. Run on real VDR doc with minimal org data
2. Review generated assumptions for reasonableness
3. Check confidence scores are varied (not all same)
4. Verify assumption_basis cites correct sources

**Success Criteria:**
- Assumptions match human expectations (not wildly off)
- Industry benchmarks applied correctly
- Size adjustments reasonable

---

## Benefits

### Why This Approach

**Rule-based heuristics** (not LLM-generated) provide:
- Deterministic, testable behavior
- Fast execution (<50ms for full generation)
- Transparent logic (audit trail via assumption_basis)
- No API costs for assumption generation

**Industry benchmarks + size heuristics** provide:
- Grounded assumptions (not arbitrary)
- Defensible to M&A teams ("based on Gartner data")
- Calibrated conservatism (avoid over-optimistic structures)

**Confidence scoring** (0.6-0.8 range) signals:
- These are educated guesses, not facts
- Lower confidence than observed data (0.8-1.0)
- Transparency for downstream cost estimates

### Alternatives Considered

**Alternative 1: LLM-generated assumptions**
- Pros: More creative, can synthesize context
- Cons: Costly, slow, non-deterministic, hard to audit
- Decision: Rule-based for speed/cost/auditability

**Alternative 2: Single default structure (no industry/size adjustment)**
- Pros: Simpler logic
- Cons: Less accurate, doesn't match reality
- Decision: Industry + size heuristics better match real orgs

---

## Expectations

### Success Metrics

**Accuracy:**
- Assumed layer counts within 1 layer of actual (when validation data available)
- Span of control assumptions within 20% of actual

**Coverage:**
- MISSING hierarchy generates 5-15 assumptions (enough for inventory analysis)
- PARTIAL hierarchy fills all gaps identified by detector

**Performance:**
- Assumption generation <50ms for typical case
- Memory usage <20MB for generation logic

---

## Risks & Mitigations

### Technical Risks

| Risk | Impact | Mitigation |
|------|--------|------------|
| **Industry benchmarks outdated** | Inaccurate assumptions | Update benchmarks annually, cite sources in comments |
| **Headcount extraction fails** | Wrong size adjustments | Fallback to conservative default (50), log warning |
| **Role title inference ambiguous** | Wrong layer assignments | Only infer when confident (exact match), else skip |
| **Assumptions conflict with partial observed data** | Inconsistent inventory | Gap-filling logic checks for existing data first |

### Implementation Risks

| Risk | Impact | Mitigation |
|------|--------|------------|
| **Assumption confidence too high** | Users trust as real data | Cap at 0.8, document rationale |
| **Assumptions too generic** | Not useful for analysis | Domain-specific roles (not just "Manager") |

---

## Results Criteria

### Acceptance Criteria

- [ ] `OrganizationAssumption` dataclass with to_fact() method
- [ ] `generate_org_assumptions()` returns assumptions for MISSING/PARTIAL
- [ ] Industry benchmarks defined for 5+ industries
- [ ] Company size adjustments for 5 size tiers
- [ ] Role title inference for 20+ common titles
- [ ] Full structure generation creates 5-15 assumptions
- [ ] Gap filling supplements existing data without conflicts
- [ ] Confidence scores in 0.6-0.8 range
- [ ] assumption_basis field populated with source
- [ ] All unit tests pass (9+ tests)
- [ ] Integration tests pass

---

**Estimated Implementation Time:** 6-8 hours
**Confidence:** Medium (heuristics require calibration/testing)
