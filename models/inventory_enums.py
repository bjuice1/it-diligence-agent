"""
Inventory Data Source Enumerations

Defines provenance tracking for inventory items to distinguish observed data
(extracted from documents) from assumed data (generated by heuristics).

Part of adaptive organization extraction feature (spec 10).
"""

from enum import Enum
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from stores.fact_store import Fact


class InventoryDataSource(Enum):
    """Provenance of inventory item data.

    Used to distinguish between:
    - OBSERVED: Data directly extracted from source documents (high confidence)
    - ASSUMED: Data generated by assumption engine based on heuristics (medium confidence)
    - HYBRID: Mix of observed and assumed data (e.g., role observed, reports_to assumed)
    """
    OBSERVED = "observed"
    ASSUMED = "assumed"
    HYBRID = "hybrid"

    @classmethod
    def from_fact(cls, fact: 'Fact') -> 'InventoryDataSource':
        """Determine data source from fact metadata.

        Args:
            fact: Fact object with optional details.data_source field

        Returns:
            InventoryDataSource enum value

        Algorithm:
            1. Check fact.details['data_source']
            2. Default to OBSERVED if not specified
            3. Map string value to enum
        """
        details = fact.details or {}
        data_source = details.get('data_source', 'observed')

        if data_source == 'assumed':
            return cls.ASSUMED
        elif data_source == 'hybrid':
            return cls.HYBRID
        else:
            return cls.OBSERVED

    @property
    def display_label(self) -> str:
        """Human-readable label for UI rendering.

        Returns:
            - "Documented" for observed data
            - "Assumed" for assumed data
            - "Partial" for hybrid data
        """
        return {
            'observed': 'Documented',
            'assumed': 'Assumed',
            'hybrid': 'Partial',
        }[self.value]

    @property
    def badge_color(self) -> str:
        """CSS class for UI badge styling.

        Returns:
            - "badge-success" (green) for observed
            - "badge-warning" (yellow/orange) for assumed
            - "badge-info" (blue) for hybrid
        """
        return {
            'observed': 'badge-success',   # Green - high confidence
            'assumed': 'badge-warning',    # Yellow - medium confidence
            'hybrid': 'badge-info',        # Blue - mixed confidence
        }[self.value]

    @property
    def is_verified(self) -> bool:
        """Whether this data is verified from documents.

        Returns:
            True for OBSERVED, False for ASSUMED/HYBRID
        """
        return self == InventoryDataSource.OBSERVED


# Confidence score ranges for different data sources
CONFIDENCE_RANGES = {
    'observed': (0.8, 1.0),    # High confidence: directly from documents
    'hybrid': (0.7, 0.9),      # Medium-high: some observed, some assumed
    'assumed': (0.6, 0.8),     # Medium: generated by heuristics
}


def validate_confidence(data_source: str, confidence: float) -> bool:
    """Validate confidence score matches data source expectations.

    Args:
        data_source: "observed", "assumed", or "hybrid"
        confidence: Confidence score (0.0-1.0)

    Returns:
        True if confidence is within expected range for data source

    Examples:
        >>> validate_confidence("observed", 0.95)  # True
        >>> validate_confidence("assumed", 0.95)   # False (too high for assumption)
        >>> validate_confidence("assumed", 0.70)   # True
    """
    if data_source not in CONFIDENCE_RANGES:
        return False

    min_conf, max_conf = CONFIDENCE_RANGES[data_source]
    return min_conf <= confidence <= max_conf
